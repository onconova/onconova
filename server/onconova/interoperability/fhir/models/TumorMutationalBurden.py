# Code autogenerated by Fhircraft 0.3.1 on 2025-10-09 07:26:50.029502.

# Fhircraft modules
import fhircraft
from fhircraft.utils import model_rebuild_all
from fhircraft.fhir.resources.datatypes.primitives import *
from fhircraft.fhir.resources.base import FHIRBaseModel
import fhircraft.fhir.resources.validators as fhir_validators
# Pydantic modules
from pydantic import Field, field_validator, model_validator, BaseModel
from pydantic.fields import FieldInfo

# Standard modules
from typing import Optional, Literal, Union
from enum import Enum
NoneType = type(None)

# Dynamic modules 
 
from fhircraft.fhir.resources.base import FHIRBaseModel,FHIRSliceModel
 
from typing import Optional,List,Annotated,Union,Literal
 
from fhircraft.fhir.resources.datatypes.primitives import String,Uri,Code,DateTime,Instant
 
from fhircraft.fhir.resources.datatypes.R4.complex_types import Element,Meta,Narrative,Resource,Extension,CodeableConcept,Reference,Identifier,Coding,Period,Timing,Quantity,Annotation,BackboneElement,Range
 
from fhircraft.fhir.resources.validators import get_type_choice_value_by_base,validate_element_constraint,validate_type_choice_element,validate_model_constraint,validate_FHIR_element_pattern,validate_slicing_cardinalities,validate_contained_resource

 
class ObsSecondaryFinding(FHIRSliceModel):
    """
    Secondary findings are genetic test results that provide information about variants in a gene unrelated to the primary purpose for the testing, most often discovered when [Whole Exome Sequencing (WES)](https://en.wikipedia.org/wiki/Exome_sequencing) or [Whole Genome Sequencing (WGS)](https://en.wikipedia.org/wiki/Whole_genome_sequencing) is performed. This extension should be used to denote when a genetic finding is being shared as a secondary finding, and ideally refer to a corresponding guideline or policy statement.

For more detail, please see:
https://ghr.nlm.nih.gov/primer/testing/secondaryfindings.
    """
    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['http://hl7.org/fhir/StructureDefinition/observation-secondaryFinding'] = Field(
        description="identifies the meaning of the extension",
        default="http://hl7.org/fhir/StructureDefinition/observation-secondaryFinding",
    )
    valueCodeableConcept: Optional[CodeableConcept] = Field(
        description="Value of extension",
        default=None,
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=True,
        )



    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

 
class BodyStructureReference(FHIRSliceModel):
    """
    Record details about the anatomical location of a specimen or body part. This resource may be used when a coded concept does not provide the necessary detail needed for the use case.
    """
    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['http://hl7.org/fhir/StructureDefinition/bodySite'] = Field(
        description="identifies the meaning of the extension",
        default="http://hl7.org/fhir/StructureDefinition/bodySite",
    )
    valueReference: Optional[Reference] = Field(
        description="Value of extension",
        default=None,
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[Reference],
            field_name_base="value",
            required=True,
        )



    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

 
class LabCategory(CodeableConcept):
    """
    Classification of  type of observation
    """
    extension: Optional[List[Extension]] = Field(
        description="Additional content defined by implementations",
        default=None,
    )
    coding: List[Coding] = Field(
        description="Code defined by a terminology system",
        default=[Coding(system=http://terminology.hl7.org/CodeSystem/observation-category, code=laboratory)],
    )


    @field_validator(*('text', 'coding', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @field_validator(*('coding',), mode="after", check_fields=None)
    @classmethod
    def FHIR_coding_pattern_constraint(cls, value):    
        return validate_FHIR_element_pattern(cls, value, 
            pattern=Coding(system='http://terminology.hl7.org/CodeSystem/observation-category', code='laboratory'),
        )


 
class BodyStructureReferenceReferenceRange(BackboneElement):
    """
    Guidance on how to interpret the value by comparison to a normal or recommended range.  Multiple reference ranges are interpreted as an "OR".   In other words, to represent two distinct target populations, two `referenceRange` elements would be used.
    """
    low: Optional[Quantity] = Field(
        description="Low Range, if relevant",
        default=None,
    )
    high: Optional[Quantity] = Field(
        description="High Range, if relevant",
        default=None,
    )
    type: Optional[CodeableConcept] = Field(
        description="Reference range qualifier",
        default=None,
    )
    appliesTo: Optional[List[CodeableConcept]] = Field(
        description="Reference range population",
        default=None,
    )
    age: Optional[Range] = Field(
        description="Applicable age range, if relevant",
        default=None,
    )
    text: Optional[String] = Field(
        description="Text based reference range in an observation",
        default=None,
    )
    text_ext: Optional[Element] = Field(
        description="Placeholder element for text extensions",
        default=None,
        alias="_text",
    )


    @field_validator(*('text', 'age', 'appliesTo', 'type', 'high', 'low', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )


 
class ConclusionString(BackboneElement):
    """
    Clinical Conclusion
    """
    extension: Optional[List[Extension]] = Field(
        description="Additional content defined by implementations",
        default=None,
    )
    modifierExtension: Optional[List[Extension]] = Field(
        description="Extensions that cannot be ignored even if unrecognized",
        default=None,
    )
    code: CodeableConcept = Field(
        description="conclusion-string",
        default_factory=lambda: CodeableConcept(coding=[{'system': 'http://hl7.org/fhir/uv/genomics-reporting/CodeSystem/tbd-codes-cs', 'code': 'conclusion-string'}]),
    )
    valueString: Optional[String] = Field(
        description="Summary conclusion (interpretation/impression)",
        default=None,
    )
    dataAbsentReason: Optional[CodeableConcept] = Field(
        description="Why the component result is missing",
        default=None,
    )
    interpretation: Optional[List[CodeableConcept]] = Field(
        description="High, low, normal, etc.",
        default=None,
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('interpretation', 'dataAbsentReason', 'code', 'modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @field_validator(*('code',), mode="after", check_fields=None)
    @classmethod
    def FHIR_code_pattern_constraint(cls, value):    
        return validate_FHIR_element_pattern(cls, value, 
            pattern=CodeableConcept(coding=[{'system': 'http://hl7.org/fhir/uv/genomics-reporting/CodeSystem/tbd-codes-cs', 'code': 'conclusion-string'}]),
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[String],
            field_name_base="value",
            required=False,
        )

 
class BodyStructureReference(FHIRBaseModel):
    """
    A profile representing tumor mutational burden for a cancer patient. 

This profile extends the GenomicsReporting IG [TumorMutationalBurden profile](http://hl7.org/fhir/uv/genomics-reporting/StructureDefinition/tmb) to include specific constraints and extensions relevant to Onconova.
    """
    id: Optional[String] = Field(
        description="Logical id of this artifact",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    meta: Optional[Meta] = Field(
        title="Meta",
        description="Metadata about the resource.",
        default_factory=lambda: Meta(versionId='0.1.0', profile=['http://luisfabib.github.io/onconova/StructureDefinition/onconova-tumor-mutational-burden']),
    )
    implicitRules: Optional[Uri] = Field(
        description="A set of rules under which this content was created",
        default=None,
    )
    implicitRules_ext: Optional[Element] = Field(
        description="Placeholder element for implicitRules extensions",
        default=None,
        alias="_implicitRules",
    )
    language: Optional[Code] = Field(
        description="Language of the resource content",
        default=None,
    )
    language_ext: Optional[Element] = Field(
        description="Placeholder element for language extensions",
        default=None,
        alias="_language",
    )
    text: Optional[Narrative] = Field(
        description="Text summary of the resource, for human interpretation",
        default=None,
    )
    contained: Optional[List[Resource]] = Field(
        description="Contained, inline Resources",
        default=None,
    )
    extension: Optional[List[Annotated[Union[ObsSecondaryFinding, "BodyStructureReference", Extension], Field(union_mode='left_to_right')]]] = Field(
        description="Extension",
        default=None,
    )
    modifierExtension: Optional[List[Extension]] = Field(
        description="Extensions that cannot be ignored",
        default=None,
    )
    identifier: Optional[List[Identifier]] = Field(
        description="Business Identifier for observation",
        default=None,
    )
    basedOn: Optional[List[Reference]] = Field(
        description="Fulfills plan, proposal or order",
        default=None,
    )
    partOf: Optional[List[Reference]] = Field(
        description="Part of referenced event",
        default=None,
    )
    status: Code = Field(
        description="registered | preliminary | final | amended +",
        default="final",
    )
    status_ext: Optional[Element] = Field(
        description="Placeholder element for status extensions",
        default=None,
        alias="_status",
    )
    category: Optional[List[Annotated[Union[LabCategory, CodeableConcept], Field(union_mode='left_to_right')]]] = Field(
        description="Classification of  type of observation",
        default=None,
    )
    code: CodeableConcept = Field(
        description="94076-7",
        default_factory=lambda: CodeableConcept(coding=[{'system': 'http://loinc.org', 'code': '94076-7'}]),
    )
    subject: Optional[Reference] = Field(
        description="Who and/or what the observation is about",
        default=None,
    )
    focus: Optional[List[Reference]] = Field(
        description="What the observation is about, when it is not about the subject of record",
        default=None,
    )
    encounter: Optional[Reference] = Field(
        description="Healthcare event during which this observation is made",
        default=None,
    )
    effectiveDateTime: Optional[DateTime] = Field(
        description="Clinically relevant time/time-period for observation",
        default=None,
    )
    effectivePeriod: Optional[Period] = Field(
        description="Clinically relevant time/time-period for observation",
        default=None,
    )
    effectiveTiming: Optional[Timing] = Field(
        description="Clinically relevant time/time-period for observation",
        default=None,
    )
    effectiveInstant: Optional[Instant] = Field(
        description="Clinically relevant time/time-period for observation",
        default=None,
    )
    issued: Optional[Instant] = Field(
        description="Date/Time this version was made available",
        default=None,
    )
    issued_ext: Optional[Element] = Field(
        description="Placeholder element for issued extensions",
        default=None,
        alias="_issued",
    )
    performer: Optional[List[Reference]] = Field(
        description="Who is responsible for the observation",
        default=None,
    )
    valueQuantity: Optional[Quantity] = Field(
        description="Actual result",
        default=None,
    )
    dataAbsentReason: Optional[CodeableConcept] = Field(
        description="Why the result is missing",
        default=None,
    )
    interpretation: Optional[List[CodeableConcept]] = Field(
        description="High, low, normal, etc.",
        default=None,
    )
    note: Optional[List[Annotation]] = Field(
        description="Comments about the Observation that also contain a coded type",
        default=None,
    )
    bodySite: Optional[CodeableConcept] = Field(
        description="Observed body part",
        default=None,
    )
    method: Optional[CodeableConcept] = Field(
        description="How it was done",
        default=None,
    )
    specimen: Optional[Reference] = Field(
        description="Specimen used for this observation",
        default=None,
    )
    device: Optional[Reference] = Field(
        description="(Measurement) Device",
        default=None,
    )
    referenceRange: Optional[List[BodyStructureReferenceReferenceRange]] = Field(
        description="Provides guide for interpretation",
        default=None,
    )
    hasMember: Optional[List[Reference]] = Field(
        description="Related resource that belongs to the Observation group",
        default=None,
    )
    derivedFrom: Optional[List[Reference]] = Field(
        description="Related measurements the observation is made from",
        default=None,
    )
    component: Optional[List[Annotated[Union[ConclusionString, BackboneElement], Field(union_mode='left_to_right')]]] = Field(
        description="Component results",
        default=None,
    )
    resourceType: Literal['Observation'] = Field(
        description=None,
        default="Observation",
    )
    @property 
    def effective(self):
        return get_type_choice_value_by_base(self, 
            base="effective",
        )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('component', 'derivedFrom', 'hasMember', 'referenceRange', 'device', 'specimen', 'method', 'bodySite', 'note', 'interpretation', 'dataAbsentReason', 'performer', 'issued', 'encounter', 'focus', 'subject', 'code', 'category', 'status', 'partOf', 'basedOn', 'identifier', 'modifierExtension', 'extension', 'text', 'language', 'implicitRules', 'meta'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def extension_slicing_cardinality_validator(cls, value):    
        return validate_slicing_cardinalities(cls, value, 
            field_name="extension",
        )



    @field_validator(*('status',), mode="after", check_fields=None)
    @classmethod
    def FHIR_status_pattern_constraint(cls, value):    
        return validate_FHIR_element_pattern(cls, value, 
            pattern="final",
        )



    @field_validator(*('category',), mode="after", check_fields=None)
    @classmethod
    def category_slicing_cardinality_validator(cls, value):    
        return validate_slicing_cardinalities(cls, value, 
            field_name="category",
        )



    @field_validator(*('code',), mode="after", check_fields=None)
    @classmethod
    def FHIR_code_pattern_constraint(cls, value):    
        return validate_FHIR_element_pattern(cls, value, 
            pattern=CodeableConcept(coding=[{'system': 'http://loinc.org', 'code': '94076-7'}]),
        )



    @field_validator(*('referenceRange',), mode="after", check_fields=None)
    @classmethod
    def FHIR_obs_3_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="low.exists() or high.exists() or text.exists()",
            human="Must have at least a low or a high or text",
            key="obs-3",
            severity="error",
        )



    @field_validator(*('component',), mode="after", check_fields=None)
    @classmethod
    def component_slicing_cardinality_validator(cls, value):    
        return validate_slicing_cardinalities(cls, value, 
            field_name="component",
        )



    @field_validator(*('contained',), mode="plain", check_fields=None)
    @classmethod
    def contained_FHIR_resource_validator(cls, value):    
        return validate_contained_resource(cls, value, 
            release="R4",
        )




    @model_validator(mode="after")
    def effective_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[DateTime, Period, Timing, Instant],
            field_name_base="effective",
            required=False,
        )



    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[Quantity],
            field_name_base="value",
            required=False,
        )



    @model_validator(mode="after")
    def FHIR_dom_2_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.contained.empty()",
            human="If the resource is contained in another resource, it SHALL NOT contain nested Resources",
            key="dom-2",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_3_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.where((('#'+id in (%resource.descendants().reference | %resource.descendants().as(canonical) | %resource.descendants().as(uri) | %resource.descendants().as(url))) or descendants().where(reference = '#').exists() or descendants().where(as(canonical) = '#').exists() or descendants().where(as(canonical) = '#').exists()).not()).trace('unmatched', id).empty()",
            human="If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource or SHALL refer to the containing resource",
            key="dom-3",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_4_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.meta.versionId.empty() and contained.meta.lastUpdated.empty()",
            human="If a resource is contained in another resource, it SHALL NOT have a meta.versionId or a meta.lastUpdated",
            key="dom-4",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_5_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.meta.security.empty()",
            human="If a resource is contained in another resource, it SHALL NOT have a security label",
            key="dom-5",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_6_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="text.`div`.exists()",
            human="A resource should have narrative for robust management",
            key="dom-6",
            severity="warning",
        )



    @model_validator(mode="after")
    def FHIR_obs_6_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="dataAbsentReason.empty() or value.empty()",
            human="dataAbsentReason SHALL only be present if Observation.value[x] is not present",
            key="obs-6",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_obs_7_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="value.empty() or component.code.where(coding.intersect(%resource.code.coding).exists()).empty()",
            human="If Observation.code is the same as an Observation.component.code then the value element associated with the code SHALL NOT be present",
            key="obs-7",
            severity="error",
        )


