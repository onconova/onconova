# Code autogenerated by Fhircraft 0.3.1 on 2025-10-09 07:26:40.127197.

# Fhircraft modules
from enum import Enum

# Standard modules
from typing import Literal, Optional, Union

import fhircraft
import fhircraft.fhir.resources.validators as fhir_validators
from fhircraft.fhir.resources.base import FHIRBaseModel
from fhircraft.fhir.resources.datatypes.primitives import *
from fhircraft.utils import model_rebuild_all

# Pydantic modules
from pydantic import BaseModel, Field, field_validator, model_validator
from pydantic.fields import FieldInfo

NoneType = type(None)

# Dynamic modules

from typing import Annotated, List, Literal, Optional, Union

from fhircraft.fhir.resources.base import FHIRBaseModel, FHIRSliceModel
from fhircraft.fhir.resources.datatypes.primitives import Code, DateTime, String, Uri
from fhircraft.fhir.resources.datatypes.R4.complex_types import (
    Age,
    Annotation,
    BackboneElement,
    CodeableConcept,
    Element,
    Extension,
    Identifier,
    Meta,
    Narrative,
    Period,
    Range,
    Reference,
    Resource,
)
from fhircraft.fhir.resources.validators import (
    get_type_choice_value_by_base,
    validate_contained_resource,
    validate_element_constraint,
    validate_FHIR_element_pattern,
    validate_model_constraint,
    validate_slicing_cardinalities,
    validate_type_choice_element,
)


class ConditionAssertedDate(FHIRSliceModel):
    """
    When the asserter identified the allergy, intolerance, condition, problem, or diagnosis or other event, situation, issue, or clinical concept that may have risen to a level of or remains a concern.  For example, when the patient experiences chest pain, the asserted date represents when the clinician began following the chest pain - not when the patient experienced the chest pain.  Asserted date supports the recognition that information is not always entered in a system immediately.  Assertion and recording are different acts, so asserted date and recorded date are semantically different. However, they may be the same date and close in time.  If this difference is significant for your use case, assertion date may be useful.
    """

    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal["http://hl7.org/fhir/StructureDefinition/condition-assertedDate"] = (
        Field(
            description="identifies the meaning of the extension",
            default="http://hl7.org/fhir/StructureDefinition/condition-assertedDate",
        )
    )
    valueDateTime: Optional[DateTime] = Field(
        description="Value of extension",
        default=None,
    )

    @property
    def value(self):
        return get_type_choice_value_by_base(
            self,
            base="value",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element(
            self,
            field_types=[DateTime],
            field_name_base="value",
            required=True,
        )

    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )


class HistologyMorphologyBehavior(FHIRSliceModel):
    """
    An extension describing the morphologic and behavioral characteristics of the cancer.
    """

    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal[
        "http://hl7.org/fhir/us/mcode/StructureDefinition/mcode-histology-morphology-behavior"
    ] = Field(
        description="identifies the meaning of the extension",
        default="http://hl7.org/fhir/us/mcode/StructureDefinition/mcode-histology-morphology-behavior",
    )
    valueCodeableConcept: Optional[CodeableConcept] = Field(
        description="Value of extension",
        default=None,
    )

    @property
    def value(self):
        return get_type_choice_value_by_base(
            self,
            base="value",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element(
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=True,
        )

    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )


class ConditionRelated(FHIRSliceModel):
    """
    This condition has an unspecified relationship with another condition.
    """

    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal["http://hl7.org/fhir/StructureDefinition/condition-related"] = Field(
        description="identifies the meaning of the extension",
        default="http://hl7.org/fhir/StructureDefinition/condition-related",
    )
    valueReference: Optional[Reference] = Field(
        description="Value of extension",
        default=None,
    )

    @property
    def value(self):
        return get_type_choice_value_by_base(
            self,
            base="value",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element(
            self,
            field_types=[Reference],
            field_name_base="value",
            required=True,
        )

    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )


class UsCore(CodeableConcept):
    """
    (USCDI) problem-list-item | health-concern
    """

    pass


class ScreeningAssessment(CodeableConcept):
    """
    (USCDI) USCDI Health Status/Assessments Data Class
    """

    pass


class BodyLocationQualifier(FHIRSliceModel):
    """
    Qualifier to refine an body location. These include qualifiers for relative location, directionality, number, and plane, and exclude qualifiers for laterality.
    """

    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal[
        "http://hl7.org/fhir/us/mcode/StructureDefinition/mcode-body-location-qualifier"
    ] = Field(
        description="identifies the meaning of the extension",
        default="http://hl7.org/fhir/us/mcode/StructureDefinition/mcode-body-location-qualifier",
    )
    valueCodeableConcept: Optional[CodeableConcept] = Field(
        description="Value of extension",
        default=None,
    )

    @property
    def value(self):
        return get_type_choice_value_by_base(
            self,
            base="value",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element(
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=True,
        )

    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )


class LateralityQualifier(FHIRSliceModel):
    """
    Qualifier to specify laterality.
    """

    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal[
        "http://hl7.org/fhir/us/mcode/StructureDefinition/mcode-laterality-qualifier"
    ] = Field(
        description="identifies the meaning of the extension",
        default="http://hl7.org/fhir/us/mcode/StructureDefinition/mcode-laterality-qualifier",
    )
    valueCodeableConcept: Optional[CodeableConcept] = Field(
        description="Value of extension",
        default=None,
    )

    @property
    def value(self):
        return get_type_choice_value_by_base(
            self,
            base="value",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element(
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=True,
        )

    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )


class ConditionRelatedBodySite(CodeableConcept):
    """
    The anatomical location where this condition manifests itself.
    """

    extension: Optional[
        List[
            Annotated[
                Union[BodyLocationQualifier, LateralityQualifier, Extension],
                Field(union_mode="left_to_right"),
            ]
        ]
    ] = Field(
        description=None,
        default=None,
    )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def extension_slicing_cardinality_validator(cls, value):
        return validate_slicing_cardinalities(
            cls,
            value,
            field_name="extension",
        )


class LateralityQualifierStage(BackboneElement):
    """
    Not used in this profile
    """

    summary: Optional[CodeableConcept] = Field(
        description="Simple summary (disease specific)",
        default=None,
    )
    assessment: Optional[List[Reference]] = Field(
        description="Formal record of assessment",
        default=None,
    )
    type: Optional[CodeableConcept] = Field(
        description="Kind of staging",
        default=None,
    )

    @field_validator(
        *(
            "type",
            "assessment",
            "summary",
            "modifierExtension",
            "extension",
            "modifierExtension",
            "extension",
            "modifierExtension",
            "extension",
        ),
        mode="after",
        check_fields=None
    )
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )


class LateralityQualifierEvidence(BackboneElement):
    """
    Not used in this profile
    """

    code: Optional[List[CodeableConcept]] = Field(
        description="Manifestation/symptom",
        default=None,
    )
    detail: Optional[List[Reference]] = Field(
        description="Supporting information found elsewhere",
        default=None,
    )

    @field_validator(
        *(
            "detail",
            "code",
            "modifierExtension",
            "extension",
            "modifierExtension",
            "extension",
        ),
        mode="after",
        check_fields=None
    )
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )


class LateralityQualifier(FHIRBaseModel):
    """
        A profile recording the a secondary neoplasm, including location and the date of onset of metastases. A secondary cancer results from the spread (metastasization) of cancer from its original site (Definition from: NCI Dictionary of Cancer Terms).

    It constrains the mCODE [SecondaryCancerCCondition profile](http://hl7.org/fhir/us/mcode/StructureDefinition/mcode-secondary-cancer-condition) to constrain the terminologies of the cancer topography and morphology extensions to use exclusively ICD-O-3 codes.
    """

    id: Optional[String] = Field(
        description="Logical id of this artifact",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    meta: Optional[Meta] = Field(
        title="Meta",
        description="Metadata about the resource.",
        default_factory=lambda: Meta(
            versionId="0.1.0",
            profile=[
                "http://onconova.github.io/fhir/StructureDefinition/onconova-secondary-cancer-condition"
            ],
        ),
    )
    implicitRules: Optional[Uri] = Field(
        description="A set of rules under which this content was created",
        default=None,
    )
    implicitRules_ext: Optional[Element] = Field(
        description="Placeholder element for implicitRules extensions",
        default=None,
        alias="_implicitRules",
    )
    language: Optional[Code] = Field(
        description="Language of the resource content",
        default=None,
    )
    language_ext: Optional[Element] = Field(
        description="Placeholder element for language extensions",
        default=None,
        alias="_language",
    )
    text: Optional[Narrative] = Field(
        description="Text summary of the resource, for human interpretation",
        default=None,
    )
    contained: Optional[List[Resource]] = Field(
        description="Contained, inline Resources",
        default=None,
    )
    extension: Optional[
        List[
            Annotated[
                Union[
                    ConditionAssertedDate,
                    HistologyMorphologyBehavior,
                    ConditionRelated,
                    Extension,
                ],
                Field(union_mode="left_to_right"),
            ]
        ]
    ] = Field(
        description="Extension",
        default=None,
    )
    modifierExtension: Optional[List[Extension]] = Field(
        description="Extensions that cannot be ignored",
        default=None,
    )
    identifier: Optional[List[Identifier]] = Field(
        description="External Ids for this condition",
        default=None,
    )
    clinicalStatus: Optional[CodeableConcept] = Field(
        description="(USCDI) active | recurrence | relapse | inactive | remission | resolved",
        default=None,
    )
    verificationStatus: Optional[CodeableConcept] = Field(
        description="Not used in this profile",
        default=None,
    )
    category: Optional[
        List[
            Annotated[
                Union[UsCore, ScreeningAssessment, CodeableConcept],
                Field(union_mode="left_to_right"),
            ]
        ]
    ] = Field(
        description="(USCDI) category codes",
        default=None,
    )
    severity: Optional[CodeableConcept] = Field(
        description="Not used in this profile",
        default=None,
    )
    code: CodeableConcept = Field(
        description="(USCDI) Identification of the condition, problem or diagnosis",
        default_factory=lambda: CodeableConcept(
            coding=[
                {
                    "system": "http://snomed.info/sct",
                    "code": "128462008",
                    "display": "Secondary malignant neoplastic disease",
                }
            ]
        ),
    )
    bodySite: Optional[List[ConditionRelatedBodySite]] = Field(
        description="Anatomical location, if relevant",
        default=None,
    )
    subject: Optional[Reference] = Field(
        description="(USCDI) Who has the condition?",
        default=None,
    )
    encounter: Optional[Reference] = Field(
        description="Not used in this profile",
        default=None,
    )
    onsetDateTime: Optional[DateTime] = Field(
        description="(USCDI) Estimated or actual date,  date-time, or age",
        default=None,
    )
    onsetAge: Optional[Age] = Field(
        description="(USCDI) Estimated or actual date,  date-time, or age",
        default=None,
    )
    onsetPeriod: Optional[Period] = Field(
        description="(USCDI) Estimated or actual date,  date-time, or age",
        default=None,
    )
    onsetRange: Optional[Range] = Field(
        description="(USCDI) Estimated or actual date,  date-time, or age",
        default=None,
    )
    onsetString: Optional[String] = Field(
        description="(USCDI) Estimated or actual date,  date-time, or age",
        default=None,
    )
    abatementDateTime: Optional[DateTime] = Field(
        description="(USCDI) When in resolution/remission",
        default=None,
    )
    abatementAge: Optional[Age] = Field(
        description="(USCDI) When in resolution/remission",
        default=None,
    )
    abatementPeriod: Optional[Period] = Field(
        description="(USCDI) When in resolution/remission",
        default=None,
    )
    abatementRange: Optional[Range] = Field(
        description="(USCDI) When in resolution/remission",
        default=None,
    )
    abatementString: Optional[String] = Field(
        description="(USCDI) When in resolution/remission",
        default=None,
    )
    recordedDate: Optional[DateTime] = Field(
        description="Not used in this profile",
        default=None,
    )
    recordedDate_ext: Optional[Element] = Field(
        description="Placeholder element for recordedDate extensions",
        default=None,
        alias="_recordedDate",
    )
    recorder: Optional[Reference] = Field(
        description="Not used in this profile",
        default=None,
    )
    asserter: Optional[Reference] = Field(
        description="Not used in this profile",
        default=None,
    )
    stage: Optional[List[LateralityQualifierStage]] = Field(
        description="Not used in this profile",
        default=None,
    )
    evidence: Optional[List[LateralityQualifierEvidence]] = Field(
        description="Not used in this profile",
        default=None,
    )
    note: Optional[List[Annotation]] = Field(
        description="Additional information about the Condition",
        default=None,
    )
    resourceType: Literal["Condition"] = Field(
        description=None,
        default="Condition",
    )

    @property
    def onset(self):
        return get_type_choice_value_by_base(
            self,
            base="onset",
        )

    @property
    def abatement(self):
        return get_type_choice_value_by_base(
            self,
            base="abatement",
        )

    @field_validator(
        *(
            "note",
            "evidence",
            "stage",
            "asserter",
            "recorder",
            "recordedDate",
            "encounter",
            "subject",
            "bodySite",
            "code",
            "severity",
            "category",
            "verificationStatus",
            "clinicalStatus",
            "identifier",
            "modifierExtension",
            "extension",
            "text",
            "language",
            "implicitRules",
            "meta",
        ),
        mode="after",
        check_fields=None
    )
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )

    @field_validator(
        *("modifierExtension", "extension"), mode="after", check_fields=None
    )
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

    @field_validator(*("extension",), mode="after", check_fields=None)
    @classmethod
    def extension_slicing_cardinality_validator(cls, value):
        return validate_slicing_cardinalities(
            cls,
            value,
            field_name="extension",
        )

    @field_validator(*("category",), mode="after", check_fields=None)
    @classmethod
    def category_slicing_cardinality_validator(cls, value):
        return validate_slicing_cardinalities(
            cls,
            value,
            field_name="category",
        )

    @field_validator(*("code",), mode="after", check_fields=None)
    @classmethod
    def FHIR_code_pattern_constraint(cls, value):
        return validate_FHIR_element_pattern(
            cls,
            value,
            pattern=CodeableConcept(
                coding=[
                    {
                        "system": "http://snomed.info/sct",
                        "code": "128462008",
                        "display": "Secondary malignant neoplastic disease",
                    }
                ]
            ),
        )

    @field_validator(*("stage",), mode="after", check_fields=None)
    @classmethod
    def FHIR_con_1_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="summary.exists() or assessment.exists()",
            human="Stage SHALL have summary or assessment",
            key="con-1",
            severity="error",
        )

    @field_validator(*("evidence",), mode="after", check_fields=None)
    @classmethod
    def FHIR_con_2_constraint_validator(cls, value):
        return validate_element_constraint(
            cls,
            value,
            expression="code.exists() or detail.exists()",
            human="evidence SHALL have code or details",
            key="con-2",
            severity="error",
        )

    @field_validator(*("contained",), mode="plain", check_fields=None)
    @classmethod
    def contained_FHIR_resource_validator(cls, value):
        return validate_contained_resource(
            cls,
            value,
            release="R4",
        )

    @model_validator(mode="after")
    def onset_type_choice_validator(self):
        return validate_type_choice_element(
            self,
            field_types=[DateTime, Age, Period, Range, String],
            field_name_base="onset",
            required=False,
        )

    @model_validator(mode="after")
    def abatement_type_choice_validator(self):
        return validate_type_choice_element(
            self,
            field_types=[DateTime, Age, Period, Range, String],
            field_name_base="abatement",
            required=False,
        )

    @model_validator(mode="after")
    def FHIR_con_3_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="clinicalStatus.exists() or verificationStatus.coding.where(system='http://terminology.hl7.org/CodeSystem/condition-ver-status' and code = 'entered-in-error').exists() or category.select($this='problem-list-item').empty()",
            human="Condition.clinicalStatus SHALL be present if verificationStatus is not entered-in-error and category is problem-list-item",
            key="con-3",
            severity="warning",
        )

    @model_validator(mode="after")
    def FHIR_con_4_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="abatement.empty() or clinicalStatus.coding.where(system='http://terminology.hl7.org/CodeSystem/condition-clinical' and (code='resolved' or code='remission' or code='inactive')).exists()",
            human="If condition is abated, then clinicalStatus must be either inactive, resolved, or remission",
            key="con-4",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_con_5_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="verificationStatus.coding.where(system='http://terminology.hl7.org/CodeSystem/condition-ver-status' and code='entered-in-error').empty() or clinicalStatus.empty()",
            human="Condition.clinicalStatus SHALL NOT be present if verification Status is entered-in-error",
            key="con-5",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_dom_2_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="contained.contained.empty()",
            human="If the resource is contained in another resource, it SHALL NOT contain nested Resources",
            key="dom-2",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_dom_3_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="contained.where((('#'+id in (%resource.descendants().reference | %resource.descendants().as(canonical) | %resource.descendants().as(uri) | %resource.descendants().as(url))) or descendants().where(reference = '#').exists() or descendants().where(as(canonical) = '#').exists() or descendants().where(as(canonical) = '#').exists()).not()).trace('unmatched', id).empty()",
            human="If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource or SHALL refer to the containing resource",
            key="dom-3",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_dom_4_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="contained.meta.versionId.empty() and contained.meta.lastUpdated.empty()",
            human="If a resource is contained in another resource, it SHALL NOT have a meta.versionId or a meta.lastUpdated",
            key="dom-4",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_dom_5_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="contained.meta.security.empty()",
            human="If a resource is contained in another resource, it SHALL NOT have a security label",
            key="dom-5",
            severity="error",
        )

    @model_validator(mode="after")
    def FHIR_dom_6_constraint_model_validator(self):
        return validate_model_constraint(
            self,
            expression="text.`div`.exists()",
            human="A resource should have narrative for robust management",
            key="dom-6",
            severity="warning",
        )
