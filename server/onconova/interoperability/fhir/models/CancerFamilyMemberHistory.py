# Code autogenerated by Fhircraft 0.3.1 on 2025-10-09 07:26:46.668655.

# Fhircraft modules
import fhircraft
from fhircraft.utils import model_rebuild_all
from fhircraft.fhir.resources.datatypes.primitives import *
from fhircraft.fhir.resources.base import FHIRBaseModel
import fhircraft.fhir.resources.validators as fhir_validators
# Pydantic modules
from pydantic import Field, field_validator, model_validator, BaseModel
from pydantic.fields import FieldInfo

# Standard modules
from typing import Optional, Literal, Union
from enum import Enum
NoneType = type(None)

# Dynamic modules 
 
from fhircraft.fhir.resources.base import FHIRBaseModel,FHIRSliceModel
 
from typing import Optional,List,Annotated,Union,Literal
 
from fhircraft.fhir.resources.datatypes.primitives import String,Uri,Code,Canonical,DateTime,Date,Boolean
 
from fhircraft.fhir.resources.datatypes.R4.complex_types import Element,Meta,Narrative,Resource,Extension,Identifier,CodeableConcept,Reference,Period,Age,Range,Annotation,BackboneElement
 
from fhircraft.fhir.resources.validators import get_type_choice_value_by_base,validate_element_constraint,validate_type_choice_element,validate_model_constraint,validate_slicing_cardinalities,validate_FHIR_element_pattern,validate_contained_resource

 
class CancerMorphology(FHIRSliceModel):
    """
    The morphology of the cancer, represented by a ICD-O-3 code.
    """
    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['http://luisfabib.github.io/onconova/StructureDefinition/onconova-ext-cancer-morphology'] = Field(
        description="identifies the meaning of the extension",
        default="http://luisfabib.github.io/onconova/StructureDefinition/onconova-ext-cancer-morphology",
    )
    valueCodeableConcept: Optional[CodeableConcept] = Field(
        description="Value of extension",
        default=None,
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=False,
        )



    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

 
class CancerTopography(FHIRSliceModel):
    """
    The topography of the cancer, represented by a ICD-O-3 code.
    """
    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['http://luisfabib.github.io/onconova/StructureDefinition/onconova-ext-cancer-topography'] = Field(
        description="identifies the meaning of the extension",
        default="http://luisfabib.github.io/onconova/StructureDefinition/onconova-ext-cancer-topography",
    )
    valueCodeableConcept: Optional[CodeableConcept] = Field(
        description="Value of extension",
        default=None,
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=False,
        )



    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )

 
class CancerCondition(BackboneElement):
    """
    Condition that the related person had
    """
    extension: Optional[List[Annotated[Union[CancerMorphology, CancerTopography, Extension], Field(union_mode='left_to_right')]]] = Field(
        description="Extension",
        default=None,
    )
    modifierExtension: Optional[List[Extension]] = Field(
        description="Extensions that cannot be ignored even if unrecognized",
        default=None,
    )
    code: CodeableConcept = Field(
        description="Condition suffered by relation",
        default_factory=lambda: CodeableConcept(coding=[{'system': 'http://snomed.info/sct', 'code': '363346000', 'display': 'Malignant neoplastic disease (disorder)'}]),
    )
    outcome: Optional[CodeableConcept] = Field(
        description="deceased | permanent disability | etc.",
        default=None,
    )
    contributedToDeath: Optional[Boolean] = Field(
        description="Whether the condition contributed to the cause of death",
        default=None,
    )
    contributedToDeath_ext: Optional[Element] = Field(
        description="Placeholder element for contributedToDeath extensions",
        default=None,
        alias="_contributedToDeath",
    )
    onsetAge: Optional[Age] = Field(
        description="When condition first manifested",
        default=None,
    )
    note: Optional[List[Annotation]] = Field(
        description="Extra information about condition",
        default=None,
    )
    @property 
    def onset(self):
        return get_type_choice_value_by_base(self, 
            base="onset",
        )


    @field_validator(*('note', 'contributedToDeath', 'outcome', 'code', 'modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def extension_slicing_cardinality_validator(cls, value):    
        return validate_slicing_cardinalities(cls, value, 
            field_name="extension",
        )



    @field_validator(*('code',), mode="after", check_fields=None)
    @classmethod
    def FHIR_code_pattern_constraint(cls, value):    
        return validate_FHIR_element_pattern(cls, value, 
            pattern=CodeableConcept(coding=[{'system': 'http://snomed.info/sct', 'code': '363346000', 'display': 'Malignant neoplastic disease (disorder)'}]),
        )




    @model_validator(mode="after")
    def onset_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[Age],
            field_name_base="onset",
            required=False,
        )

 
class CancerTopography(FHIRBaseModel):
    """
    A profile recording of a family member's history of cancer.

This profile is based on the core FHIR `FamilyMemberHistory` resource rather than the mCODE  [HistoryOfMetastaticCancer profile](http://hl7.org/fhir/us/mcode/StructureDefinition/mcode-history-of-metastatic-cancer) to allow for a broader range of cancer history documentation (not limited to metastatic cancer). It includes constraints to ensure that at least one cancer condition is recorded, along with optional extensions for cancer morphology and topography.
    """
    id: Optional[String] = Field(
        description="Logical id of this artifact",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    meta: Optional[Meta] = Field(
        title="Meta",
        description="Metadata about the resource.",
        default_factory=lambda: Meta(versionId='0.1.0', profile=['http://luisfabib.github.io/onconova/StructureDefinition/onconova-cancer-family-member-history']),
    )
    implicitRules: Optional[Uri] = Field(
        description="A set of rules under which this content was created",
        default=None,
    )
    implicitRules_ext: Optional[Element] = Field(
        description="Placeholder element for implicitRules extensions",
        default=None,
        alias="_implicitRules",
    )
    language: Optional[Code] = Field(
        description="Language of the resource content",
        default=None,
    )
    language_ext: Optional[Element] = Field(
        description="Placeholder element for language extensions",
        default=None,
        alias="_language",
    )
    text: Optional[Narrative] = Field(
        description="Text summary of the resource, for human interpretation",
        default=None,
    )
    contained: Optional[List[Resource]] = Field(
        description="Contained, inline Resources",
        default=None,
    )
    extension: Optional[List[Extension]] = Field(
        description="Additional content defined by implementations",
        default=None,
    )
    modifierExtension: Optional[List[Extension]] = Field(
        description="Extensions that cannot be ignored",
        default=None,
    )
    identifier: Optional[List[Identifier]] = Field(
        description="External Id(s) for this record",
        default=None,
    )
    instantiatesCanonical: Optional[List[Canonical]] = Field(
        description="Instantiates FHIR protocol or definition",
        default=None,
    )
    instantiatesCanonical_ext: Optional[Element] = Field(
        description="Placeholder element for instantiatesCanonical extensions",
        default=None,
        alias="_instantiatesCanonical",
    )
    instantiatesUri: Optional[List[Uri]] = Field(
        description="Instantiates external protocol or definition",
        default=None,
    )
    instantiatesUri_ext: Optional[Element] = Field(
        description="Placeholder element for instantiatesUri extensions",
        default=None,
        alias="_instantiatesUri",
    )
    status: Code = Field(
        description="partial | completed | entered-in-error | health-unknown",
        default="completed",
    )
    status_ext: Optional[Element] = Field(
        description="Placeholder element for status extensions",
        default=None,
        alias="_status",
    )
    dataAbsentReason: Optional[CodeableConcept] = Field(
        description="subject-unknown | withheld | unable-to-obtain | deferred",
        default=None,
    )
    patient: Optional[Reference] = Field(
        description="Patient history is about",
        default=None,
    )
    date: Optional[DateTime] = Field(
        description="When history was recorded or last updated",
        default=None,
    )
    date_ext: Optional[Element] = Field(
        description="Placeholder element for date extensions",
        default=None,
        alias="_date",
    )
    name: Optional[String] = Field(
        description="Not used in this profile",
        default=None,
    )
    name_ext: Optional[Element] = Field(
        description="Placeholder element for name extensions",
        default=None,
        alias="_name",
    )
    relationship: Optional[CodeableConcept] = Field(
        description="Relationship to the subject",
        default=None,
    )
    sex: Optional[CodeableConcept] = Field(
        description="Not used in this profile",
        default=None,
    )
    bornPeriod: Optional[Period] = Field(
        description="Not used in this profile",
        default=None,
    )
    bornDate: Optional[Date] = Field(
        description="Not used in this profile",
        default=None,
    )
    bornString: Optional[String] = Field(
        description="Not used in this profile",
        default=None,
    )
    ageAge: Optional[Age] = Field(
        description="Not used in this profile",
        default=None,
    )
    ageRange: Optional[Range] = Field(
        description="Not used in this profile",
        default=None,
    )
    ageString: Optional[String] = Field(
        description="Not used in this profile",
        default=None,
    )
    estimatedAge: Optional[Boolean] = Field(
        description="Not used in this profile",
        default=None,
    )
    estimatedAge_ext: Optional[Element] = Field(
        description="Placeholder element for estimatedAge extensions",
        default=None,
        alias="_estimatedAge",
    )
    deceasedBoolean: Optional[Boolean] = Field(
        description="Dead? How old/when?",
        default=None,
    )
    reasonCode: Optional[List[CodeableConcept]] = Field(
        description="Not used in this profile",
        default=None,
    )
    reasonReference: Optional[List[Reference]] = Field(
        description="Not used in this profile",
        default=None,
    )
    note: Optional[List[Annotation]] = Field(
        description="General note about related person",
        default=None,
    )
    condition: Optional[List[Annotated[Union[CancerCondition, BackboneElement], Field(union_mode='left_to_right')]]] = Field(
        description="Condition that the related person had",
        default=None,
    )
    resourceType: Literal['FamilyMemberHistory'] = Field(
        description=None,
        default="FamilyMemberHistory",
    )
    @property 
    def born(self):
        return get_type_choice_value_by_base(self, 
            base="born",
        )
    @property 
    def age(self):
        return get_type_choice_value_by_base(self, 
            base="age",
        )
    @property 
    def deceased(self):
        return get_type_choice_value_by_base(self, 
            base="deceased",
        )


    @field_validator(*('condition', 'note', 'reasonReference', 'reasonCode', 'estimatedAge', 'sex', 'relationship', 'name', 'date', 'patient', 'dataAbsentReason', 'status', 'instantiatesUri', 'instantiatesCanonical', 'identifier', 'modifierExtension', 'extension', 'text', 'language', 'implicitRules', 'meta'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @field_validator(*('status',), mode="after", check_fields=None)
    @classmethod
    def FHIR_status_pattern_constraint(cls, value):    
        return validate_FHIR_element_pattern(cls, value, 
            pattern="completed",
        )



    @field_validator(*('condition',), mode="after", check_fields=None)
    @classmethod
    def condition_slicing_cardinality_validator(cls, value):    
        return validate_slicing_cardinalities(cls, value, 
            field_name="condition",
        )



    @field_validator(*('contained',), mode="plain", check_fields=None)
    @classmethod
    def contained_FHIR_resource_validator(cls, value):    
        return validate_contained_resource(cls, value, 
            release="R4",
        )




    @model_validator(mode="after")
    def born_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[Period, Date, String],
            field_name_base="born",
            required=False,
        )



    @model_validator(mode="after")
    def age_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[Age, Range, String],
            field_name_base="age",
            required=False,
        )



    @model_validator(mode="after")
    def deceased_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[Boolean],
            field_name_base="deceased",
            required=False,
        )



    @model_validator(mode="after")
    def FHIR_dom_2_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.contained.empty()",
            human="If the resource is contained in another resource, it SHALL NOT contain nested Resources",
            key="dom-2",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_3_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.where((('#'+id in (%resource.descendants().reference | %resource.descendants().as(canonical) | %resource.descendants().as(uri) | %resource.descendants().as(url))) or descendants().where(reference = '#').exists() or descendants().where(as(canonical) = '#').exists() or descendants().where(as(canonical) = '#').exists()).not()).trace('unmatched', id).empty()",
            human="If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource or SHALL refer to the containing resource",
            key="dom-3",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_4_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.meta.versionId.empty() and contained.meta.lastUpdated.empty()",
            human="If a resource is contained in another resource, it SHALL NOT have a meta.versionId or a meta.lastUpdated",
            key="dom-4",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_5_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.meta.security.empty()",
            human="If a resource is contained in another resource, it SHALL NOT have a security label",
            key="dom-5",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_6_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="text.`div`.exists()",
            human="A resource should have narrative for robust management",
            key="dom-6",
            severity="warning",
        )



    @model_validator(mode="after")
    def FHIR_fhs_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="age.empty() or born.empty()",
            human="Can have age[x] or born[x], but not both",
            key="fhs-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_fhs_2_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="age.exists() or estimatedAge.empty()",
            human="Can only have estimatedAge if age[x] is present",
            key="fhs-2",
            severity="error",
        )


