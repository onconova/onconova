# Code autogenerated by Fhircraft 0.3.1 on 2025-10-09 07:27:01.178164.

# Fhircraft modules
import fhircraft
from fhircraft.utils import model_rebuild_all
from fhircraft.fhir.resources.datatypes.primitives import *
from fhircraft.fhir.resources.base import FHIRBaseModel
import fhircraft.fhir.resources.validators as fhir_validators
# Pydantic modules
from pydantic import Field, field_validator, model_validator, BaseModel
from pydantic.fields import FieldInfo

# Standard modules
from typing import Optional, Literal, Union
from enum import Enum
NoneType = type(None)

# Dynamic modules 
 
from fhircraft.fhir.resources.base import FHIRBaseModel,FHIRSliceModel
 
from typing import Optional,List,Annotated,Union,Literal
 
from fhircraft.fhir.resources.datatypes.primitives import String,Uri,Code,Integer,Base64Binary,Boolean,Canonical,Date,DateTime,Decimal,Id,Instant,Markdown,Oid,PositiveInt,Time,UnsignedInt,Url,Uuid
 
from fhircraft.fhir.resources.datatypes.R4.complex_types import Element,Meta,Narrative,Resource,Extension,Address,Age,Annotation,Attachment,CodeableConcept,Coding,ContactPoint,Count,Distance,Duration,HumanName,Identifier,Money,Period,Quantity,Range,Ratio,Reference,SampledData,Signature,Timing,ContactDetail,Contributor,DataRequirement,Expression,ParameterDefinition,RelatedArtifact,TriggerDefinition,UsageContext,Dosage,BackboneElement
 
from fhircraft.fhir.resources.validators import get_type_choice_value_by_base,validate_element_constraint,validate_type_choice_element,validate_model_constraint,validate_slicing_cardinalities,validate_FHIR_element_pattern,validate_contained_resource

 
class CTCGrade(FHIRSliceModel):
    """
    The grade of the adverse event as defined by the Common Terminology Criteria for Adverse Events (CTCAE).
    """
    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['http://luisfabib.github.io/onconova/StructureDefinition/onconova-ext-ctc-grade'] = Field(
        description="identifies the meaning of the extension",
        default="http://luisfabib.github.io/onconova/StructureDefinition/onconova-ext-ctc-grade",
    )
    valueInteger: Optional[Integer] = Field(
        description="CTCAE Grade",
        default=None,
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[Integer],
            field_name_base="value",
            required=False,
        )



    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_ctcae_grade_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="valueInteger() >= 1 and valueInteger() <= 5",
            human="The CTCAE grade must be between 1 and 5, inclusive.",
            key="ctcae-grade",
            severity="error",
        )

 
class Category(Extension):
    """
    Mitigation Category
    """
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['category'] = Field(
        description="identifies the meaning of the extension",
        default="category",
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=False,
        )

 
class Adjustment(Extension):
    """
    Treatment Adjustment
    """
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['adjustment'] = Field(
        description="identifies the meaning of the extension",
        default="adjustment",
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=False,
        )

 
class Drug(Extension):
    """
    Mitigation Drug
    """
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['drug'] = Field(
        description="identifies the meaning of the extension",
        default="drug",
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=False,
        )

 
class Procedure(Extension):
    """
    Mitigation Procedure
    """
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['procedure'] = Field(
        description="identifies the meaning of the extension",
        default="procedure",
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=False,
        )

 
class Management(Extension):
    """
    Management
    """
    extension: Optional[Extension] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['management'] = Field(
        description="identifies the meaning of the extension",
        default="management",
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[CodeableConcept],
            field_name_base="value",
            required=False,
        )

 
class AdverseEventMitigation(FHIRSliceModel):
    """
    Details about an action taken to mitigate or manage the adverse event.
    """
    id: Optional[String] = Field(
        description="Unique id for inter-element referencing",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    extension: Optional[List[Annotated[Union[Category, Adjustment, Drug, Procedure, Management, Extension], Field(union_mode='left_to_right')]]] = Field(
        description="Extension",
        default=None,
    )
    url: Literal['http://luisfabib.github.io/onconova/StructureDefinition/onconova-ext-adverse-event-mitigation'] = Field(
        description="identifies the meaning of the extension",
        default="http://luisfabib.github.io/onconova/StructureDefinition/onconova-ext-adverse-event-mitigation",
    )
    valueBase64Binary: Optional[Base64Binary] = Field(
        description="Value of extension",
        default=None,
    )
    valueBoolean: Optional[Boolean] = Field(
        description="Value of extension",
        default=None,
    )
    valueCanonical: Optional[Canonical] = Field(
        description="Value of extension",
        default=None,
    )
    valueCode: Optional[Code] = Field(
        description="Value of extension",
        default=None,
    )
    valueDate: Optional[Date] = Field(
        description="Value of extension",
        default=None,
    )
    valueDateTime: Optional[DateTime] = Field(
        description="Value of extension",
        default=None,
    )
    valueDecimal: Optional[Decimal] = Field(
        description="Value of extension",
        default=None,
    )
    valueId: Optional[Id] = Field(
        description="Value of extension",
        default=None,
    )
    valueInstant: Optional[Instant] = Field(
        description="Value of extension",
        default=None,
    )
    valueInteger: Optional[Integer] = Field(
        description="Value of extension",
        default=None,
    )
    valueMarkdown: Optional[Markdown] = Field(
        description="Value of extension",
        default=None,
    )
    valueOid: Optional[Oid] = Field(
        description="Value of extension",
        default=None,
    )
    valuePositiveInt: Optional[PositiveInt] = Field(
        description="Value of extension",
        default=None,
    )
    valueString: Optional[String] = Field(
        description="Value of extension",
        default=None,
    )
    valueTime: Optional[Time] = Field(
        description="Value of extension",
        default=None,
    )
    valueUnsignedInt: Optional[UnsignedInt] = Field(
        description="Value of extension",
        default=None,
    )
    valueUri: Optional[Uri] = Field(
        description="Value of extension",
        default=None,
    )
    valueUrl: Optional[Url] = Field(
        description="Value of extension",
        default=None,
    )
    valueUuid: Optional[Uuid] = Field(
        description="Value of extension",
        default=None,
    )
    valueAddress: Optional[Address] = Field(
        description="Value of extension",
        default=None,
    )
    valueAge: Optional[Age] = Field(
        description="Value of extension",
        default=None,
    )
    valueAnnotation: Optional[Annotation] = Field(
        description="Value of extension",
        default=None,
    )
    valueAttachment: Optional[Attachment] = Field(
        description="Value of extension",
        default=None,
    )
    valueCodeableConcept: Optional[CodeableConcept] = Field(
        description="Value of extension",
        default=None,
    )
    valueCoding: Optional[Coding] = Field(
        description="Value of extension",
        default=None,
    )
    valueContactPoint: Optional[ContactPoint] = Field(
        description="Value of extension",
        default=None,
    )
    valueCount: Optional[Count] = Field(
        description="Value of extension",
        default=None,
    )
    valueDistance: Optional[Distance] = Field(
        description="Value of extension",
        default=None,
    )
    valueDuration: Optional[Duration] = Field(
        description="Value of extension",
        default=None,
    )
    valueHumanName: Optional[HumanName] = Field(
        description="Value of extension",
        default=None,
    )
    valueIdentifier: Optional[Identifier] = Field(
        description="Value of extension",
        default=None,
    )
    valueMoney: Optional[Money] = Field(
        description="Value of extension",
        default=None,
    )
    valuePeriod: Optional[Period] = Field(
        description="Value of extension",
        default=None,
    )
    valueQuantity: Optional[Quantity] = Field(
        description="Value of extension",
        default=None,
    )
    valueRange: Optional[Range] = Field(
        description="Value of extension",
        default=None,
    )
    valueRatio: Optional[Ratio] = Field(
        description="Value of extension",
        default=None,
    )
    valueReference: Optional[Reference] = Field(
        description="Value of extension",
        default=None,
    )
    valueSampledData: Optional[SampledData] = Field(
        description="Value of extension",
        default=None,
    )
    valueSignature: Optional[Signature] = Field(
        description="Value of extension",
        default=None,
    )
    valueTiming: Optional[Timing] = Field(
        description="Value of extension",
        default=None,
    )
    valueContactDetail: Optional[ContactDetail] = Field(
        description="Value of extension",
        default=None,
    )
    valueContributor: Optional[Contributor] = Field(
        description="Value of extension",
        default=None,
    )
    valueDataRequirement: Optional[DataRequirement] = Field(
        description="Value of extension",
        default=None,
    )
    valueExpression: Optional[Expression] = Field(
        description="Value of extension",
        default=None,
    )
    valueParameterDefinition: Optional[ParameterDefinition] = Field(
        description="Value of extension",
        default=None,
    )
    valueRelatedArtifact: Optional[RelatedArtifact] = Field(
        description="Value of extension",
        default=None,
    )
    valueTriggerDefinition: Optional[TriggerDefinition] = Field(
        description="Value of extension",
        default=None,
    )
    valueUsageContext: Optional[UsageContext] = Field(
        description="Value of extension",
        default=None,
    )
    valueDosage: Optional[Dosage] = Field(
        description="Value of extension",
        default=None,
    )
    valueMeta: Optional[Meta] = Field(
        description="Value of extension",
        default=None,
    )
    @property 
    def value(self):
        return get_type_choice_value_by_base(self, 
            base="value",
        )


    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def extension_slicing_cardinality_validator(cls, value):    
        return validate_slicing_cardinalities(cls, value, 
            field_name="extension",
        )




    @model_validator(mode="after")
    def value_type_choice_validator(self):
        return validate_type_choice_element( 
            self,
            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, Address, Age, Annotation, Attachment, CodeableConcept, Coding, ContactPoint, Count, Distance, Duration, HumanName, Identifier, Money, Period, Quantity, Range, Ratio, Reference, SampledData, Signature, Timing, ContactDetail, Contributor, DataRequirement, Expression, ParameterDefinition, RelatedArtifact, TriggerDefinition, UsageContext, Dosage, Meta],
            field_name_base="value",
            required=False,
        )



    @model_validator(mode="after")
    def FHIR_ele_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_ext_1_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_drug_mitigation_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension('category').valueCodeableConcept.coding.code = 'C49158' implies (extension('drug').exists() and not extension('procedure').exists() and not extension('adjustment').exists())",
            human="If the mitigation category is 'Drug', then only mitigation drug must be specified.",
            key="drug-mitigation",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_adjustment_mitigation_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension('category').valueCodeableConcept.coding.code = 'C49157' implies (extension('adjustment').exists() and not extension('procedure').exists() and not extension('drug').exists())",
            human="If the mitigation category is 'Adjustment', then only mitigation adjustment must be specified.",
            key="adjustment-mitigation",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_procedural_mitigation_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="extension('category').valueCodeableConcept.coding.code = 'C49159' implies (extension('procedure').exists() and not extension('adjustment').exists() and not extension('drug').exists())",
            human="If the mitigation category is 'Procedure', then only mitigation procedure must be specified.",
            key="procedural-mitigation",
            severity="error",
        )

 
class AdverseEventMitigationSuspectEntityCausality(BackboneElement):
    """
    Information on the possible cause of the event.
    """
    assessment: Optional[CodeableConcept] = Field(
        description="Assessment of if the entity caused the event",
        default=None,
    )
    productRelatedness: Optional[String] = Field(
        description="AdverseEvent.suspectEntity.causalityProductRelatedness",
        default=None,
    )
    productRelatedness_ext: Optional[Element] = Field(
        description="Placeholder element for productRelatedness extensions",
        default=None,
        alias="_productRelatedness",
    )
    author: Optional[Reference] = Field(
        description="AdverseEvent.suspectEntity.causalityAuthor",
        default=None,
    )
    method: Optional[CodeableConcept] = Field(
        description="ProbabilityScale | Bayesian | Checklist",
        default=None,
    )


    @field_validator(*('method', 'author', 'productRelatedness', 'assessment', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )


 
class AdverseEventMitigationSuspectEntity(BackboneElement):
    """
    Describes the entity that is suspected to have caused the adverse event.
    """
    instance: Optional[Reference] = Field(
        description="Refers to the specific entity that caused the adverse event",
        default=None,
    )
    causality: Optional[List[AdverseEventMitigationSuspectEntityCausality]] = Field(
        description="Information on the possible cause of the event",
        default=None,
    )


    @field_validator(*('causality', 'instance', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )


 
class AdverseEventMitigation(FHIRBaseModel):
    """
    A profile representing an adverse event experienced by a cancer patient as a result of an antineoplastic treatment, structured according to the Common Terminology Criteria for Adverse Events (CTCAE). This resource is used to capture and standardize the documentation of adverse events occurring during cancer care, including the type of event, its CTCAE grade, and any mitigation actions taken.

The profile constrains the base FHIR `AdverseEvent` resource to ensure consistent use of CTCAE codes and grades, and supports linkage to related treatments such as medications, radiotherapy, or surgical procedures documented in Onconova. The profile also provides extensions for recording mitigation strategies, supporting detailed tracking and management of adverse events in cancer patients.
    """
    id: Optional[String] = Field(
        description="Logical id of this artifact",
        default=None,
    )
    id_ext: Optional[Element] = Field(
        description="Placeholder element for id extensions",
        default=None,
        alias="_id",
    )
    meta: Optional[Meta] = Field(
        title="Meta",
        description="Metadata about the resource.",
        default_factory=lambda: Meta(versionId='0.1.0', profile=['http://luisfabib.github.io/onconova/StructureDefinition/onconova-adverse-event']),
    )
    implicitRules: Optional[Uri] = Field(
        description="A set of rules under which this content was created",
        default=None,
    )
    implicitRules_ext: Optional[Element] = Field(
        description="Placeholder element for implicitRules extensions",
        default=None,
        alias="_implicitRules",
    )
    language: Optional[Code] = Field(
        description="Language of the resource content",
        default=None,
    )
    language_ext: Optional[Element] = Field(
        description="Placeholder element for language extensions",
        default=None,
        alias="_language",
    )
    text: Optional[Narrative] = Field(
        description="Text summary of the resource, for human interpretation",
        default=None,
    )
    contained: Optional[List[Resource]] = Field(
        description="Contained, inline Resources",
        default=None,
    )
    extension: Optional[List[Annotated[Union[CTCGrade, "AdverseEventMitigation", Extension], Field(union_mode='left_to_right')]]] = Field(
        description="Extension",
        default=None,
    )
    modifierExtension: Optional[List[Extension]] = Field(
        description="Extensions that cannot be ignored",
        default=None,
    )
    identifier: Optional[Identifier] = Field(
        description="Business identifier for the event",
        default=None,
    )
    actuality: Code = Field(
        description="actual | potential",
        default="actual",
    )
    actuality_ext: Optional[Element] = Field(
        description="Placeholder element for actuality extensions",
        default=None,
        alias="_actuality",
    )
    category: Optional[List[CodeableConcept]] = Field(
        description="Not used in this profile",
        default=None,
    )
    event: Optional[CodeableConcept] = Field(
        description="Type of the event itself in relation to the subject",
        default=None,
    )
    subject: Optional[Reference] = Field(
        description="Subject impacted by event",
        default=None,
    )
    encounter: Optional[Reference] = Field(
        description="Not used in this profile",
        default=None,
    )
    date: Optional[DateTime] = Field(
        description="When the event occurred",
        default=None,
    )
    date_ext: Optional[Element] = Field(
        description="Placeholder element for date extensions",
        default=None,
        alias="_date",
    )
    detected: Optional[DateTime] = Field(
        description="Not used in this profile",
        default=None,
    )
    detected_ext: Optional[Element] = Field(
        description="Placeholder element for detected extensions",
        default=None,
        alias="_detected",
    )
    recordedDate: Optional[DateTime] = Field(
        description="Not used in this profile",
        default=None,
    )
    recordedDate_ext: Optional[Element] = Field(
        description="Placeholder element for recordedDate extensions",
        default=None,
        alias="_recordedDate",
    )
    resultingCondition: Optional[List[Reference]] = Field(
        description="Not used in this profile",
        default=None,
    )
    location: Optional[Reference] = Field(
        description="Not used in this profile",
        default=None,
    )
    seriousness: Optional[CodeableConcept] = Field(
        description="Not used in this profile",
        default=None,
    )
    severity: Optional[CodeableConcept] = Field(
        description="Not used in this profile",
        default=None,
    )
    outcome: Optional[CodeableConcept] = Field(
        description="resolved | recovering | ongoing | resolvedWithSequelae | fatal | unknown",
        default=None,
    )
    recorder: Optional[Reference] = Field(
        description="Not used in this profile",
        default=None,
    )
    contributor: Optional[List[Reference]] = Field(
        description="Not used in this profile",
        default=None,
    )
    suspectEntity: Optional[List[AdverseEventMitigationSuspectEntity]] = Field(
        description="The suspected agent causing the adverse event",
        default=None,
    )
    subjectMedicalHistory: Optional[List[Reference]] = Field(
        description="AdverseEvent.subjectMedicalHistory",
        default=None,
    )
    referenceDocument: Optional[List[Reference]] = Field(
        description="AdverseEvent.referenceDocument",
        default=None,
    )
    study: Optional[List[Reference]] = Field(
        description="AdverseEvent.study",
        default=None,
    )
    resourceType: Literal['AdverseEvent'] = Field(
        description=None,
        default="AdverseEvent",
    )


    @field_validator(*('study', 'referenceDocument', 'subjectMedicalHistory', 'suspectEntity', 'contributor', 'recorder', 'outcome', 'severity', 'seriousness', 'location', 'resultingCondition', 'recordedDate', 'detected', 'date', 'encounter', 'subject', 'event', 'category', 'actuality', 'identifier', 'modifierExtension', 'extension', 'text', 'language', 'implicitRules', 'meta'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ele_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="hasValue() or (children().count() > id.count())",
            human="All FHIR elements must have a @value or children",
            key="ele-1",
            severity="error",
        )



    @field_validator(*('modifierExtension', 'extension'), mode="after", check_fields=None)
    @classmethod
    def FHIR_ext_1_constraint_validator(cls, value):    
        return validate_element_constraint(cls, value, 
            expression="extension.exists() != value.exists()",
            human="Must have either extensions or value[x], not both",
            key="ext-1",
            severity="error",
        )



    @field_validator(*('extension',), mode="after", check_fields=None)
    @classmethod
    def extension_slicing_cardinality_validator(cls, value):    
        return validate_slicing_cardinalities(cls, value, 
            field_name="extension",
        )



    @field_validator(*('actuality',), mode="after", check_fields=None)
    @classmethod
    def FHIR_actuality_pattern_constraint(cls, value):    
        return validate_FHIR_element_pattern(cls, value, 
            pattern="actual",
        )



    @field_validator(*('contained',), mode="plain", check_fields=None)
    @classmethod
    def contained_FHIR_resource_validator(cls, value):    
        return validate_contained_resource(cls, value, 
            release="R4",
        )




    @model_validator(mode="after")
    def FHIR_dom_2_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.contained.empty()",
            human="If the resource is contained in another resource, it SHALL NOT contain nested Resources",
            key="dom-2",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_3_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.where((('#'+id in (%resource.descendants().reference | %resource.descendants().as(canonical) | %resource.descendants().as(uri) | %resource.descendants().as(url))) or descendants().where(reference = '#').exists() or descendants().where(as(canonical) = '#').exists() or descendants().where(as(canonical) = '#').exists()).not()).trace('unmatched', id).empty()",
            human="If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource or SHALL refer to the containing resource",
            key="dom-3",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_4_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.meta.versionId.empty() and contained.meta.lastUpdated.empty()",
            human="If a resource is contained in another resource, it SHALL NOT have a meta.versionId or a meta.lastUpdated",
            key="dom-4",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_5_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="contained.meta.security.empty()",
            human="If a resource is contained in another resource, it SHALL NOT have a security label",
            key="dom-5",
            severity="error",
        )



    @model_validator(mode="after")
    def FHIR_dom_6_constraint_model_validator(self):
        return validate_model_constraint( 
            self,
            expression="text.`div`.exists()",
            human="A resource should have narrative for robust management",
            key="dom-6",
            severity="warning",
        )


